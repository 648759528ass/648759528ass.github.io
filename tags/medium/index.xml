<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>medium on Jhas's Blog</title><link>https://blog.jhas.site/tags/medium/</link><description>Recent content in medium on Jhas's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 21 Feb 2022 11:12:29 +0800</lastBuildDate><atom:link href="https://blog.jhas.site/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>20220221 每日一题 Leetcode838 推多米诺</title><link>https://blog.jhas.site/p/20220221-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</link><pubDate>Mon, 21 Feb 2022 11:12:29 +0800</pubDate><guid>https://blog.jhas.site/p/20220221-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</guid><description>838. 推多米诺 题面 $n$ 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
给你一个字符串 $dominoes$ 表示这一行多米诺骨牌的初始状态，其中：
$dominoes[i]$ = &amp;lsquo;L&amp;rsquo;，表示第 $i$ 张多米诺骨牌被推向左侧，
$dominoes[i]$ = &amp;lsquo;R&amp;rsquo;，表示第 $i$ 张多米诺骨牌被推向右侧，
$dominoes[i]$ = &amp;lsquo;.'，表示没有推动第 $i$ 张多米诺骨牌。
返回表示最终状态的字符串。
解析 本题有两种思路：
bfs搜索 双指针模拟 bfs搜索 简单说一下bfs搜索的思路，对于每一个推倒的多米诺，必然会引起连锁反应引起其它多米诺倒下。维护一个队列。队列里元素为$(i)$ 再开一个数组记录当前多米诺的状态:访问?未访问。
对于每个倒下的多米诺，其一定不会对已访问的多米诺产生影响，对于一开始已经倒下的多米诺记为已访问。同时对于每次访问的多米诺，仅仅只在其被取出为队头时才记录为访问。
再次对于每个倒下的多米诺，其影响一定是左边或右边，修改其对应影响的未访问的多米诺的状态，当一个多米诺同时被两边访问(未被访问但已经为L或R)时，该多米诺为直立。
以上情况直到队列空为止
双指针模拟 对于每一个倒下的多米诺都会影响一个一个区间。只要用双指针模拟这个区间即可
解法 双指针模拟
时间复杂度: $O(n)$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: string pushDominoes(string dominoes) { int l = 0; for(int i = 0;i&amp;lt;dominoes.</description></item><item><title>20220219 每日一题 Leetcode969 煎饼排序</title><link>https://blog.jhas.site/p/20220219-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 19 Feb 2022 09:21:44 +0800</pubDate><guid>https://blog.jhas.site/p/20220219-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</guid><description>969. 煎饼排序 题面 给你一个整数数组 $arr$ ，请使用 煎饼翻转 完成对数组的排序。
一次煎饼翻转的执行过程如下：
选择一个整数 $k$ ，$1 \le k \le arr.length$ 反转子数组 $arr[0&amp;hellip;k-1]$（下标从 0 开始） 例如，$arr = [3,2,1,4]$ ，选择 $k = 3$ 进行一次煎饼翻转，反转子数组 $[3,2,1]$ ，得到 $arr = [1,2,3,4]$ 。
以数组形式返回能使 $arr$ 有序的煎饼翻转操作所对应的 $k$ 值序列。任何将数组排序且翻转次数在 $10 * arr.length$ 范围内的有效答案都将被判断为正确。
解析 考虑一下每次都将某个下标翻到第一位，然后将它再翻到它对应的位置，操作次数只需 $2 * arr.length$即可
又有如果我们要让每一次翻面不会搞乱前面的翻面，则我们应该从右往左翻。枚举每一个值即可。
代码 时间复杂度:$ O(n^2) $
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: vector&amp;lt;int&amp;gt; pancakeSort(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int n = arr.</description></item></channel></rss>