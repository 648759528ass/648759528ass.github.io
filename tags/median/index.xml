<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>median on Jhas's Blog</title><link>https://blog.jhas.site/tags/median/</link><description>Recent content in median on Jhas's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 04 Mar 2022 09:03:38 +0800</lastBuildDate><atom:link href="https://blog.jhas.site/tags/median/index.xml" rel="self" type="application/rss+xml"/><item><title>20220304 每日一题 Leetcode2104 子数组范围和</title><link>https://blog.jhas.site/p/20220304-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2104-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link><pubDate>Fri, 04 Mar 2022 09:03:38 +0800</pubDate><guid>https://blog.jhas.site/p/20220304-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2104-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid><description>2104. 子数组范围和 题面 给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。
返回 nums 中所有子数组范围的和 。
子数组是数组中一个连续 非空 的元素序列。
解析 首先直接的一个想法：暴力枚举
直接枚举l 左边界，然后枚举r右边界，维护最大与最小值。最后可以得出答案
显然以上时间复杂度为$O(n^2)$,让我们来对其加以改进。
首先我们分离范围内的最大值与最小值，即不必在每一个元素都计算出其范围，在最后的时候我们只需要把所有子数组的最大值和与最小值和相减，则可得出所有子数组范围的和，
那么我们的问题就退化为如何求所有子数组的最大值和与最小值和。
我们首先来考虑最大值。我们来枚举右边界$r$ ,然后针对每一个$r$再来枚举$l$(暴力解法反了一反)，我们可以发现对于每一个 $r$ 其枚举的$l$都是之前已经出现过的$r$。再看我们需要求的是最大值。我们设$ nums[l]&amp;hellip;nums[r]$子数组最大值点为$i$,我们可以发现任意左边界处于$[l,i)$，右边界为$r$的子数组，其最大值都为$nums[i]$。$nums[i]$就如同一个挡板一样，挡住了前面更小的数。直到我们找到前面比$nums[i]$更大的数，那么这个时候我们就可以使用单调栈来处理这个过程。
我们来考虑一个单调递减栈,里面维护一个数对 ${idx,cnt}$.我们枚举$nums$, 对于每一个$i$ ,我们首先考虑$nums[i] &amp;gt;=nums[top.idx]$ 的情况，在该种情况下对于任意$j&amp;gt;i$, 在尝试求$nums[top.idx]&amp;hellip;nums[j]$的过程中,$nums[top.idx]$ 都会被$nums[i]$挡住,在入栈$i$时我们可以把top出栈,而对于top这个数对，我们需要找到前面挡住top.idx的更前一个数对,也即top出栈后的栈顶，我们称为l_top,那么对于$nums[l_top.idx]&amp;hellip; nums[top.idx]$中的任意子数组，其最大值都为$num[top.idx]$,再考虑$k&amp;lt;l_top.idx$，这里对于任意$nums[k]&amp;hellip; nums[top.idx]$的子数组，其最大值都为$nums[l_top.idx]$。如果在这个时候清算右边界为i的子数组最大值的话，我们的时间复杂度会回退到$O(n^2)$,所以我们不应该在此时向前清算最大值，这时$cnt$的作用就来了,cnt的含义为：当前位置到前一个小值之间的被移除的位置的数量, 也即一个懒标志，先不计算这些被移除的位置的子数组，待当前数出栈时一起计算。我们出栈top的时候令$l_top.cnt = l_top.cnt + top.cnt$，答案加上$(top.idx-l_top.idx)*nums[cnt.idx]*top.cnt$
求最小值的时候思路相似，使用单调递增栈.
解法一(暴力枚举) 时间复杂度:$O(n^2)$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: long long subArrayRanges(vector&amp;lt;int&amp;gt;&amp;amp; nums) { long long ans = 0; for(int l = 0;l&amp;lt;nums.</description></item></channel></rss>