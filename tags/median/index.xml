<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>median on Jhas's Blog</title><link>https://blog.jhas.site/tags/median/</link><description>Recent content in median on Jhas's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 11 Mar 2022 08:18:06 +0800</lastBuildDate><atom:link href="https://blog.jhas.site/tags/median/index.xml" rel="self" type="application/rss+xml"/><item><title>20220311 每日一题 Leetcode2049 统计最高分的节点数目</title><link>https://blog.jhas.site/p/20220311-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2049-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</link><pubDate>Fri, 11 Mar 2022 08:18:06 +0800</pubDate><guid>https://blog.jhas.site/p/20220311-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2049-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</guid><description>2049. 统计最高分的节点数目 题面 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。
一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。
请你返回有 最高得分 节点的 数目 。
解析 有点像 树的重心 这道题，用dfs做即可。每个节点可递归计算其两个子树节点数，父节点之前的数可以用整体数量减去即可
解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: int num = 0; long long ans = 0; int cnt = 0; vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; V; int countHighestScoreNodes(vector&amp;lt;int&amp;gt;&amp;amp; parents) { num = parents.</description></item><item><title>20220308 每日一题 Leetcode2055 蜡烛之间的盘子</title><link>https://blog.jhas.site/p/20220308-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/</link><pubDate>Tue, 08 Mar 2022 22:17:50 +0800</pubDate><guid>https://blog.jhas.site/p/20220308-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/</guid><description>2055. 蜡烛之间的盘子 题面 略
解析 首先这是一道需要求区间和的问题，遇到这种问题我们自然而然地想到前缀和的方法，只需要我们记录下每个位置前面以及它自己当前位置的蜡烛数量，就可以在$O(1)$时间内求得对应的区间蜡烛数量
然后我们接下来要考虑的是如何获得查询区间的蜡烛数量，我们只需要找到左边界右边第一个蜡烛，右边界左边第一个蜡烛即可获得答案。若找到的两个蜡烛都在区间内，则可得到区间蜡烛数量，否则为0
显然蜡烛位置可以看成一个有序数组，我们可以用二分查找来找到对应的蜡烛。
另一种方法是在每个位置，记录其左边第一个蜡烛与右边第一个蜡烛，这样就可以直接对应每一个区间找到其对应的蜡烛。
解法一 二分查找 时间复杂度:$O(n+q\log n)$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: vector&amp;lt;int&amp;gt; platesBetweenCandles(string s, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; queries) { vector&amp;lt;int&amp;gt; pre(s.size(),0),ret,fx; int cnt = 0; int i = 0; while(i&amp;lt;s.</description></item><item><title>20220306 每日一题 Leetcode2100 适合打劫银行的日子</title><link>https://blog.jhas.site/p/20220306-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2100-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/</link><pubDate>Sun, 06 Mar 2022 11:56:14 +0800</pubDate><guid>https://blog.jhas.site/p/20220306-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2100-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/</guid><description>2100. 适合打劫银行的日子 题面 你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。
如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：
第 i 天前和后都分别至少有 time 天。 第 i 天前连续 time 天警卫数目都是非递增的。 第 i 天后连续 time 天警卫数目都是非递减的。 更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] &amp;gt;= security[i - time + 1] &amp;gt;= &amp;hellip; &amp;gt;= security[i] &amp;lt;= &amp;hellip; &amp;lt;= security[i + time - 1] &amp;lt;= security[i + time].
请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。
解析 这道题一开始没想到前缀和的解法，往滑动窗口那边去想了，所以这道题解法其实挺多样的。</description></item><item><title>20220304 每日一题 Leetcode2104 子数组范围和</title><link>https://blog.jhas.site/p/20220304-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2104-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link><pubDate>Fri, 04 Mar 2022 09:03:38 +0800</pubDate><guid>https://blog.jhas.site/p/20220304-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode2104-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid><description>2104. 子数组范围和 题面 给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。
返回 nums 中所有子数组范围的和 。
子数组是数组中一个连续 非空 的元素序列。
解析 首先直接的一个想法：暴力枚举
直接枚举l 左边界，然后枚举r右边界，维护最大与最小值。最后可以得出答案
显然以上时间复杂度为$O(n^2)$,让我们来对其加以改进。
首先我们分离范围内的最大值与最小值，即不必在每一个元素都计算出其范围，在最后的时候我们只需要把所有子数组的最大值和与最小值和相减，则可得出所有子数组范围的和，
那么我们的问题就退化为如何求所有子数组的最大值和与最小值和。
我们首先来考虑最大值。我们来枚举右边界$r$ ,然后针对每一个$r$再来枚举$l$(暴力解法反了一反)，我们可以发现对于每一个 $r$ 其枚举的$l$都是之前已经出现过的$r$。再看我们需要求的是最大值。我们设$ nums[l]&amp;hellip;nums[r]$子数组最大值点为$i$,我们可以发现任意左边界处于$[l,i)$，右边界为$r$的子数组，其最大值都为$nums[i]$。$nums[i]$就如同一个挡板一样，挡住了前面更小的数。直到我们找到前面比$nums[i]$更大的数，那么这个时候我们就可以使用单调栈来处理这个过程。
我们来考虑一个单调递减栈,里面维护一个数对 ${idx,cnt}$.我们枚举$nums$, 对于每一个$i$ ,我们首先考虑$nums[i] &amp;gt;=nums[top.idx]$ 的情况，在该种情况下对于任意$j&amp;gt;i$, 在尝试求$nums[top.idx]&amp;hellip;nums[j]$的过程中,$nums[top.idx]$ 都会被$nums[i]$挡住,在入栈$i$时我们可以把top出栈,而对于top这个数对，我们需要找到前面挡住top.idx的更前一个数对,也即top出栈后的栈顶，我们称为l_top,那么对于$nums[l_top.idx]&amp;hellip; nums[top.idx]$中的任意子数组，其最大值都为$num[top.idx]$,再考虑$k&amp;lt;l_top.idx$，这里对于任意$nums[k]&amp;hellip; nums[top.idx]$的子数组，其最大值都为$nums[l_top.idx]$。如果在这个时候清算右边界为i的子数组最大值的话，我们的时间复杂度会回退到$O(n^2)$,所以我们不应该在此时向前清算最大值，这时$cnt$的作用就来了,cnt的含义为：当前位置到前一个小值之间的被移除的位置的数量, 也即一个懒标志，先不计算这些被移除的位置的子数组，待当前数出栈时一起计算。我们出栈top的时候令$l_top.cnt = l_top.cnt + top.cnt$，答案加上$(top.idx-l_top.idx)*nums[cnt.idx]*top.cnt$
求最小值的时候思路相似，使用单调递增栈.
解法一(暴力枚举) 时间复杂度:$O(n^2)$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: long long subArrayRanges(vector&amp;lt;int&amp;gt;&amp;amp; nums) { long long ans = 0; for(int l = 0;l&amp;lt;nums.</description></item></channel></rss>