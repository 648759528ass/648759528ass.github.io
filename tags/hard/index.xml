<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hard on Jhas's Blog</title><link>https://blog.jhas.site/tags/hard/</link><description>Recent content in hard on Jhas's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 09 Mar 2022 07:17:37 +0800</lastBuildDate><atom:link href="https://blog.jhas.site/tags/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>20220309 每日一题 Leetcode798 得分最高的最小轮调</title><link>https://blog.jhas.site/p/20220309-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode798-%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/</link><pubDate>Wed, 09 Mar 2022 07:17:37 +0800</pubDate><guid>https://blog.jhas.site/p/20220309-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode798-%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/</guid><description>798. 得分最高的最小轮调 题面 给定一个数组 $A$，我们可以将它按一个非负整数 $K$ 进行轮调，这样可以使数组变为 $ A[K], A[K+1], A[K+2], &amp;hellip; A[A.length - 1], A[0], A[1], &amp;hellip;, A[K-1] $ 的形式。此后，任何值小于或等于其索引的项都可以记作一分。 例如，如果数组为 $[2, 4, 1, 3, 0]$，我们按 K = 2 进行轮调后，它将变成 $[1, 3, 0, 2, 4]$。这将记作 3 分，因为 1 &amp;gt; 0 [no points], 3 &amp;gt; 1 [no points], 0 &amp;lt;= 2 [one point], 2 &amp;lt;= 3 [one point], 4 &amp;lt;= 4 [one point]。
在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调索引 $K$。如果有多个答案，返回满足条件的最小的索引 $K$。
解析 这道题非常容易想到暴力解法，但是正确思路跟暴力解法是完全不一样的。
暴力解法:将数组二倍展开，然后依题意模拟计算每一个k的分数
差分解法：</description></item><item><title>20220302 每日一题 Leetcode564 寻找最近的回文数</title><link>https://blog.jhas.site/p/20220302-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode564-%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</link><pubDate>Wed, 02 Mar 2022 08:35:07 +0800</pubDate><guid>https://blog.jhas.site/p/20220302-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode564-%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/</guid><description>564. 寻找最近的回文数 题面 给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。
“最近的”定义为两个整数差的绝对值最小。
解析 这题其实不值得hard的难度，整体来说只是代码比较难写，需要分类讨论较多情况而已
首先对于个整数字符串n
我们找出它的大于它的最近回文数与小于它的最近回文数，然后把两个回文数与n的差取绝对值比较即可。
对于大回文数与小回文数，我们首先考虑的是在不对n的上半部分增减数字的情况下构造一个回文数，若这个回文数小于n，则该回文数为小回文数。反之若大于n，则该回文数为大回文数。若等于n则必须增减数字来构造回文数。
首先我们先讨论大回文数的构造：
若要取得大于n的最小回文数，则必是对n的上半部分进行一个 +1 操作(贪心的思想)(因为数字回文所以下半部分不重要)，然后使用上半部分继续构造回文数
同时我们考虑一下进位的情况:
对于 9999 来说 +1 后 变为10099 构造后 10001,为9999的上界回文数。即只需要构造即可，不需要特别在意进位。
然后我们讨论一下小回文数的构造:
与大回文数构造的思想相同,若要取得小于n的最小回文数，则必是对n的上半部分进行一个 -1 操作(贪心的思想)(因为数字回文所以下半部分不重要)，然后使用上半部分继续构造回文数.
我们再来考虑一下进位的情况。这时候我们就需要区分长度奇偶了。
先来讨论长度为偶数，进位后为奇数的情况:
对于100000 来说 -1后变 99000 假如我们直接按上部回文构造的话就会变为 99099,显然 99999 才是100000 的下界回文数，所以我们需要将中间位也变为9，
换句话来说就是检测到头部为0，需要将 len/2 这个位置变为 9
再来讨论长度为奇数，进位后为偶数的情况:
对于 10000 来说 -1 后变为 9900, 构造后变为9999 是正确的答案，所以长度为奇数进位后为偶数的情况是不需要特殊构造的。
解法 时间复杂度:$O(n)$
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 class Solution { public: long long int find_up(string n){ auto lln = parse(n); int len = n.</description></item><item><title>20220228 每日一题 Leetcode1601 最多可达成的换楼请求数目</title><link>https://blog.jhas.site/p/20220228-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1601-%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE/</link><pubDate>Mon, 28 Feb 2022 08:49:52 +0800</pubDate><guid>https://blog.jhas.site/p/20220228-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1601-%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE/</guid><description>1601. 最多可达成的换楼请求数目 题面 我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。
给你一个数组 $requests$ ，其中 $requests[i] = [from_i, to_i]$ ，表示一个员工请求从编号为 $from_i$ 的楼搬到编号为 $to_i$ 的楼。
一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。
请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。
提示：
$1\le n \le 20$ $1 \le requests.length \le 16$ $requests[i].length == 2$ $0 \le fromi, toi \lt n $ 解析 今天这道题做了好久，想复杂了，其实很简单。。。。</description></item><item><title>20220222 每日一题 Leetcode1994 好子集的数目</title><link>https://blog.jhas.site/p/20220222-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1994-%E5%A5%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE/</link><pubDate>Tue, 22 Feb 2022 14:47:07 +0800</pubDate><guid>https://blog.jhas.site/p/20220222-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1994-%E5%A5%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE/</guid><description>1994. 好子集的数目 题面 给你一个整数数组 $nums$ 。如果 $nums$ 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。
比方说，如果 $nums$ = $[1, 2, 3, 4]$ ： $[2, 3]$ ，$[1, 2, 3]$ 和 $[1, 3]$ 是 好 子集，乘积分别为 $6 = 23$ ，$6 = 23$ 和 $3 = 3$ 。 $[1, 4]$ 和 $[4]$ 不是 好 子集，因为乘积分别为 $4 = 22$ 和 $4 = 22$ 。 请你返回 $nums$ 中不同的 好 子集的数目对 $10^9 + 7$ 取余 的结果。
$nums$ 中的 子集 是通过删除 $nums$ 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。</description></item><item><title>20220216 每日一题 Leetcode1719 重构一颗树的方案数</title><link>https://blog.jhas.site/p/20220216-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1719-%E9%87%8D%E6%9E%84%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</link><pubDate>Wed, 16 Feb 2022 10:18:20 +0800</pubDate><guid>https://blog.jhas.site/p/20220216-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1719-%E9%87%8D%E6%9E%84%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</guid><description>1719. 重构一棵树的方案数 今天这道题前前后后看了两小时，最后忍不住看答案了
题面 给你一个数组 $pairs$ ，其中 $pairs[i] = [x_i, y_i]$ ，并且满足：
$pairs$ 中没有重复元素 $xi &amp;lt; yi$ 令 $ways$ 为满足下面条件的有根树的方案数：
树所包含的所有节点值都在 $pairs$ 中。 一个数对 $[xi, yi]$ 出现在 $pairs$ 中 当且仅当 $x_i$ 是 $y_i$ 的祖先或者 $y_i$ 是 $x_i$ 的祖先。 注意：构造出来的树不一定是二叉树。 两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。 请你返回：
如果 $ways == 0$，返回0。 如果 $ways == 1$，返回1。 如果 $ways &amp;gt; 1 $ ，返回 2 。
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。
我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。
解析 注意题面的当且仅当，故有以下结论
每一个能够成为根节点的值，必然与其它节点的值构成一个$pair$ 对于该树以及其子树，每一个节点的父节点的度都 大于或等于其子节点的度 每一个子节点的邻接节点集都为父节点的子集 则对于重构一颗树，我们可以先确定其根节点的值，然后枚举剩下的节点，确定其父节点的值，然后检查父节点值成立</description></item></channel></rss>