<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hard on Jhas's Blog</title><link>https://blog.jhas.site/tags/hard/</link><description>Recent content in hard on Jhas's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 16 Feb 2022 10:18:20 +0800</lastBuildDate><atom:link href="https://blog.jhas.site/tags/hard/index.xml" rel="self" type="application/rss+xml"/><item><title>20220216 每日一题 Leetcode1719 重构一颗树的方案数</title><link>https://blog.jhas.site/p/20220216-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1719-%E9%87%8D%E6%9E%84%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</link><pubDate>Wed, 16 Feb 2022 10:18:20 +0800</pubDate><guid>https://blog.jhas.site/p/20220216-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-leetcode1719-%E9%87%8D%E6%9E%84%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</guid><description>1719. 重构一棵树的方案数 今天这道题前前后后看了两小时，最后忍不住看答案了
题面 给你一个数组 $pairs$ ，其中 $pairs[i] = [x_i, y_i]$ ，并且满足：
$pairs$ 中没有重复元素 $xi &amp;lt; yi$ 令 $ways$ 为满足下面条件的有根树的方案数：
树所包含的所有节点值都在 $pairs$ 中。 一个数对 $[xi, yi]$ 出现在 $pairs$ 中 当且仅当 $x_i$ 是 $y_i$ 的祖先或者 $y_i$ 是 $x_i$ 的祖先。 注意：构造出来的树不一定是二叉树。 两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。 请你返回：
如果 $ways == 0$，返回0。 如果 $ways == 1$，返回1。 如果 $ways &amp;gt; 1 $ ，返回 2 。
一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。
我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。
解析 注意题面的当且仅当，故有以下结论
每一个能够成为根节点的值，必然与其它节点的值构成一个$pair$ 对于该树以及其子树，每一个节点的父节点的度都 大于或等于其子节点的度 每一个子节点的邻接节点集都为父节点的子集 则对于重构一颗树，我们可以先确定其根节点的值，然后枚举剩下的节点，确定其父节点的值，然后检查父节点值成立</description></item></channel></rss>